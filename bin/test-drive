#!/usr/bin/env ruby

require 'optparse'
require 'methadone'
require 'uuidtools'
require 'test/drive'

class App
  include Methadone::Main
  include Methadone::CLILogging
  include Test::Drive
  extend Test::Drive::Formatter
  extend Test::Drive::GitHelper


  main do |jenkins_url, user, api_key|


    @jenkins_url = jenkins_url
    @user = user
    @api_key = api_key
    @target_job = options['target-job']

    @client = JenkinsClient.new @jenkins_url, @user, @api_key

    create_patch options['file']
    debug File.readlines File.open options['file']

    tracking_id = UUIDTools::UUID.random_create.to_s
    id_param = {'name' => 'TRACKING_ID', 'value' => tracking_id}
    @client.upload_file_to_job(@target_job, tracking_id, options[:file])

    build_number = @client.get_build_number(@target_job, id_param, 120)

    @client.print_output(build_number, @target_job)
    result = @client.wait_for_job_status(@target_job, build_number)

    print_result(result)
    git_push if result == 'SUCCESS' || result == 'UNSTABLE'

    delete_patch options['file']
  end


  arg :jenkins_url, 'URL for the Jenkins server'
  arg :user, 'Jenkins user ID'
  arg :api_key, 'Jenkins API token'

  options['file'] = 'patch'
  on '-f PATCH_FILE', '--file', 'Path to patch file'

  options['target-job'] = 'TestDrive'
  on '-j TARGET_JOB', '--target-job', 'Jenkins job to be triggered'


  description 'A simple command-line tool for running a Jenkins test job before pushing code to the remote repo'

  version Test::Drive::VERSION

  use_log_level_option :toggle_debug_on_signal => 'USR1'

  go!
end

